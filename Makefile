# Default target when you just run "make"
all: compiler

# Define the C compiler
CC = gcc
# Define compiler flags
CFLAGS = -Wall -g

# Define source files and the final executable name
SRCS = parser.tab.c lex.yy.c
EXEC = compiler

# Rule to link the final executable
$(EXEC): $(SRCS)
	$(CC) $(CFLAGS) -o $(EXEC) $(SRCS) -lfl

# Rule to generate the parser from the bison file
# It also creates parser.tab.h
parser.tab.c: parser.y
	bison -d parser.y

# Rule to generate the lexer from the flex file
# It depends on the header generated by bison
lex.yy.c: lexer.l parser.tab.h
	flex lexer.l

# Phony targets are not files. 'test' and 'clean' are actions.
.PHONY: test clean

# The 'test' target first ensures the compiler is built, then runs tests.
test: $(EXEC)
	@echo "--- Running Tests ---"
	@mkdir -p output
	@# This line finds all input files and calls make again to process each one.
	@$(MAKE) $(patsubst input/%.svgl,output/%.svg,$(wildcard input/*.svgl))
	@echo "--- Tests completed. Check output/ folder. ---"

# Rule for processing a single input file to create an output svg
# This is called by the 'test' target.
output/%.svg: input/%.svgl $(EXEC)
	@echo "Compiling $< -> $@"
	@./$(EXEC) < $< > $@ 2> $@.err
	@# Check if the error file is empty. If it is, delete it. If not, show an error.
	@if [ ! -s $@.err ]; then \
		rm -f $@.err; \
	else \
		echo "ERROR during compilation of $<. See details in $@.err"; \
		exit 1; \
	fi
	@# Optional: create a .txt copy for easy viewing
	@cp $@ $@.txt

# The 'clean' target removes all generated files
clean:
	@echo "Cleaning up generated files..."
	rm -f $(EXEC) parser.tab.c parser.tab.h lex.yy.c
	rm -rf output